{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Commands and user manuals : Gui and setup usage Documents all data relative to the usage of the different blocks of the setup, the options to tune them and what they do. Software programmation Maze modules Morj code GUI code Maintenance and fabrication Maze Contains all info and files realtive to the maze electronics, code and mechanical parts. MORJ Contains all info and files realtive to the morj electronics, code and mechanical parts. Genicam Camera Contains all code and docs about genicam and how widefield monitoring video is captured in python during the session. SQL database Contains all documentation of queries, tables, and overall model of the database, as well as some info to deploy a new one if necessary. All 3D models you want to find TIP : You can acess all repos related to 3D files by typing 3D in the searchfield of the organization. All files related to surgeries are available in the repository Surgeries_3D . This includes parts related to windows (contour, pointing, drawing, and pushers to keep windows in place) as well as flexible \"chambers\" for intrinsic imaging. Some files related to surgeries more specific to the S1 implant are available in the folder below. All files related to the implant are available in the repository Implant_3D . This includes head fixation stuff, files sent for production of metal parts at Sculpteo, mouse (body, skull, atlases, brain), and parts of the implant per se (implant, hats, nuts & rings & models of both tips of the fiber-bundle). Some parts relative to staining, trackers and imu boards are available) Similarly, all 3D parts related to the Morj are located in Morj_3D and files relative to Maze 3D models are in Maze_3D .","title":"Home"},{"location":"index.html#commands-and-user-manuals","text":"","title":"Commands and user manuals :"},{"location":"index.html#gui-and-setup-usage","text":"Documents all data relative to the usage of the different blocks of the setup, the options to tune them and what they do.","title":"Gui and setup usage"},{"location":"index.html#software-programmation","text":"","title":"Software programmation"},{"location":"index.html#maze-modules","text":"","title":"Maze modules"},{"location":"index.html#morj-code","text":"","title":"Morj code"},{"location":"index.html#gui-code","text":"","title":"GUI code"},{"location":"index.html#maintenance-and-fabrication","text":"","title":"Maintenance and fabrication"},{"location":"index.html#maze","text":"Contains all info and files realtive to the maze electronics, code and mechanical parts.","title":"Maze"},{"location":"index.html#morj","text":"Contains all info and files realtive to the morj electronics, code and mechanical parts.","title":"MORJ"},{"location":"index.html#genicam-camera","text":"Contains all code and docs about genicam and how widefield monitoring video is captured in python during the session.","title":"Genicam Camera"},{"location":"index.html#sql-database","text":"Contains all documentation of queries, tables, and overall model of the database, as well as some info to deploy a new one if necessary.","title":"SQL database"},{"location":"index.html#all-3d-models-you-want-to-find","text":"TIP : You can acess all repos related to 3D files by typing 3D in the searchfield of the organization. All files related to surgeries are available in the repository Surgeries_3D . This includes parts related to windows (contour, pointing, drawing, and pushers to keep windows in place) as well as flexible \"chambers\" for intrinsic imaging. Some files related to surgeries more specific to the S1 implant are available in the folder below. All files related to the implant are available in the repository Implant_3D . This includes head fixation stuff, files sent for production of metal parts at Sculpteo, mouse (body, skull, atlases, brain), and parts of the implant per se (implant, hats, nuts & rings & models of both tips of the fiber-bundle). Some parts relative to staining, trackers and imu boards are available) Similarly, all 3D parts related to the Morj are located in Morj_3D and files relative to Maze 3D models are in Maze_3D .","title":"All 3D models you want to find"},{"location":"api/morj_api/morj_api.html","text":"root commands : program info Input : { i nf o : 1 } type argument value type : ignored Output : Returns information about the program file and date of the code running on the device, for traceability, under the keys : prog_file and prog_date , as strings. handshake Input : { ha n dshake : 1 } type argument value type : ignored Output : Return an handshake acceptation under key accept_handshake as boolean with value True. reboot : Input : { reboo t : 1 } type argument value type : ignored Output : Returns nothing, activates watchdog timer, and wait 15ms that it triggers a software reboot. imu : get_error: Input : { imu :{ ge t _error : 1 }} type argument value type : ignored Output : Returns status of the access between microcontroller and IMU. Possible values returned are listed here . If everything is ok, you should get : All is well. Returns a string under the key : IMU_error coupling : Coupling is separated into two classes that are both attainable with the same key. First one is responsible of keeping track of position, turns and offsets : set_status : Input : { coupli n g :{ se t _s tatus : 1 }} type Argument value type : float Must be an angle value between -180 and +180 degrees Sets the coupling mode ON (value = 1) or OFF (value=0). If the coupling is off, the position will still be computed but the motor will not be updated by these new positions until coupling is turned ON again. Output : Returns nothing. set_offset : Input : { coupli n g :{ se t _o ffset : 35.78 }} type Argument value type : float Must be an angle value between -180 and +180 degrees Output : Returns nothing. get_offset : Input : { coupli n g :{ ge t _o ffset : 1 }} type Argument value type : ignored Output : Returns the cur. set_zero : Input : { coupli n g :{ se t _zero : 1 }} type Argument value type : ignored Sets the offset to correspond to the current instantaneous position, so that it's new value will be 0 after substraction. Output : Returns nothing. get_pos : {coupling:{get_pos:1}} Returns the position of the coupling in degrees (between -180 and +180) get_summed_pos : {coupling:{get_summed_pos:1}} Returns the position of the coupling in degrees (between max int32 and min int32). This position is the accumulated rotationnal position since the MORJ is turned on. (the position at turn on is 0) Negative direction is counterclockwise. Positive is clockwise. add_turn : {coupling:{add_turn:1}} Add turns (one per command max, whatever the value) if supplying +1 : adding a clockwise turn. If supplying -1 adding a counterclockwise turn. get_turns : {coupling:{get_turns:1}} Get the number of current turns on the MORJ set_sensitivity : {coupling:{set_sensitivity:600}} Set the number of steps that have to be overcomed before the MORJ can issue command to the motor. (in absolute steps) Default is 600 (as 1 turn is 9600, 600 = 1/16th of a turn) get_last_cmd : {coupling:{get_last_cmd:1}} Get the last_motor command send to the motor, in steps, relative to the last-last command. get_last_scmd : {coupling:{get_last_scmd:1}} Get the last_motor command send to the motor, in steps, accumulated from 0 (0 = position when the MORJ turned ON) reset : {coupling:{reset:1}} Set turns , summed_pos , offset , last_command , last_summed_command to 0 motor : All the commands motor accepts, directly forwarded : handshake: {motor:{handshake:1}} Set turns , summed_pos , offset , last_command , last_summed_command to 0 go : {motor:{go:50}} Go to a given position (relative to current position) in steps. can take positive or negative integers. go_abs: DEPRECATED : DO NOT USE. (Was used to send absolute command (from the 0 of the motor) but usually creates very dangerous situations as it is hard for user, as well as software, to keep track of a variable number with extreme certainty across two distributed devices, even more when asynchronously zeroing them or reboots / crashes / disconnections are possible \"features\") get_pos: {motor:{get_pos:1}} DEPRECATED : DO NOT USE. (send absolute command (from the 0 of the motor) usually creates dangerous situations !!!!) stop : {motor:{stop:50}} Stop the motor movement, while keeping track of the destination position. lock : {motor:{lock:1}} NOT RECOMMANDED TO USE THIS COMMAND. Better use the MORJ specific lock manager by using the command {lock :{set_status:0}} to keep track of the lock status. zero: {motor:{zero:1}} Set the OREF of the motor to the current position, at which the lock will come back. (by increments of one full turn) set_motor_accel: {motor:{set_motor_accel:1}} Set the motor maximum speed in steps per second. By default, 10000 set_motor_max_speed: {motor:{set_motor_max_speed:1}} Set the motor maximum acceleration in steps per second per second. By default, 20000 This is usually the variable that have the strongest effect on the ability of the motor to make fast movements. Use with care and try increasing values slowly. If you goo to high, the motor will stall and thus the controller will loose the zero position as there is no rotary encoder on the motor or MORJ shaft. lock : set_status : {lock :{set_status:0}} Set the lock status of the motor. 0 is unlocked. 1 is locked. This takes priority over the BNC signal momentarily, but if the BNC status changes (Rise or Falls) after this command has been issued, the BNC status takes priority again. shutter : set_status : {shutter :{set_status:0}} Set the current shutter output BNC status. 0 is shutter deactivated (LOW). 1 is shutter activated. (HIGH). Remember that this MORJ output is set to INPUT_PULLUP, and so it can set a HIGH but not a LOW. To set a LOW, the other end of a BNC must be plugged into an input that can pull LOW. (all BNC compliant inputs usually can) This means that is the BNC is unplugged, there may be a RISING state detection at MORJ bootup on the shutter input line. bnc_in_1 : This line is a RefractoryInterruptInput (subclass of InterruptInput) which gets activated by rising edges (trigger mode can be configured in the code, not in the API) When activated, it can't be again activated for the refractory period. For now the refractory period can't be set in API, but in the code (it's a fast thing to change it if necessary) The refractory period is by default 1300000 microseconds, so 1.3 seconds, a bit more than the duration of the 500 pulses sent to the camera for one trial. This allows this line to generate one single trigger at the very start of a 500 Hz pulse train. After 1.3 sec, it doesn't generate anything, but simply can be activated again. This class is used to set and count the status of a trial recordings, and help the PC to save and split recordings of 1.3 sec per trial. trigger: {bnc_in_1 :{trigger:1}} Fakes a single trigger (here rising edge from code config) on the bnc_in_1input line. A trigger off will be happening 1.3 seconds after. info : {bnc_in_1 :{info:1}} Gets some info about the possible commands this class takes. bnc_in_2 : This line is a PollingInput class, and thus checks regularly in the loop if it has been activated. This is a bit unprecise and can miss very short pulses, but bnc_in_2 is used to detect the start of the session, and the stop of the session, from the maze. It does so by detecting the rising edge (session start) of a very long pulse (a pulse the length of the session) and the falling edge (session_stop) of this pulse. Hence , precise timing is not an issue. info : {bnc_in_2 :{info:1}} Gets some info about the possible commands this class takes. trigger_rising {bnc_in_2 :{trigger_rising:1}} Fakes a single rising edge on the bnc_in_2 input line. trigger_falling : {bnc_in_2 :{trigger_falling:1}} Fakes a single falling edge on the bnc_in_2 input line. records : set_select: {records:{set_select:{ \"quat\":1 , \"turns\" : 1 }}} sets the status of data sent into packets for the subset of data attributes you pass into the sub-json object. Possible keys are : \"quat\" \"accel\" \"gyro\" \"mag\" \"yaw_quat\" \"summed_yaw_coupling\" \"yaw_coupling\" \"command\" \"summed_command\" \"turns\" \"euler_quat\" get_select: {records :{get_select:1}} Gets the current selection of data into packets start: {records :{start:1}} Starts the sending of data packets at a regular interval. stop: {records:{stop:1}} Stops the sending of data packets at a regular interval. set_interval: {records :{set_interval:50}} Set interval (in milliseconds) between to data packets. (default, 50 milliseconds) set_trial_duration: {records :{set_trial_duration:1500}} The time interval (in milliseconds) after a bnc_in_1 trigger to declare the end of the trial (in recording) and increase the trial counter to 1. Set to 1500 milliseconds by default. set_quat_ref : {records :{set_quat_ref :1}} Saves a quaternion reference with the current position, to remember a \"zero\" 3D orientation position that can be substracted later in python to all the data of the session. get_quat_ref : {records :{get_quat_ref :1}} Gets the quaternion reference saved. info : {records :{info :1}} Gets some info about the possible commands this class takes.","title":"MORJ"},{"location":"api/morj_api/morj_api.html#root-commands","text":"","title":"root commands :"},{"location":"api/morj_api/morj_api.html#program-info","text":"Input : { i nf o : 1 } type argument value type : ignored Output : Returns information about the program file and date of the code running on the device, for traceability, under the keys : prog_file and prog_date , as strings.","title":"program info"},{"location":"api/morj_api/morj_api.html#handshake","text":"Input : { ha n dshake : 1 } type argument value type : ignored Output : Return an handshake acceptation under key accept_handshake as boolean with value True.","title":"handshake"},{"location":"api/morj_api/morj_api.html#reboot","text":"Input : { reboo t : 1 } type argument value type : ignored Output : Returns nothing, activates watchdog timer, and wait 15ms that it triggers a software reboot.","title":"reboot :"},{"location":"api/morj_api/morj_api.html#imu","text":"","title":"imu :"},{"location":"api/morj_api/morj_api.html#get_error","text":"Input : { imu :{ ge t _error : 1 }} type argument value type : ignored Output : Returns status of the access between microcontroller and IMU. Possible values returned are listed here . If everything is ok, you should get : All is well. Returns a string under the key : IMU_error","title":"get_error:"},{"location":"api/morj_api/morj_api.html#coupling","text":"Coupling is separated into two classes that are both attainable with the same key. First one is responsible of keeping track of position, turns and offsets :","title":"coupling :"},{"location":"api/morj_api/morj_api.html#set_status","text":"Input : { coupli n g :{ se t _s tatus : 1 }} type Argument value type : float Must be an angle value between -180 and +180 degrees Sets the coupling mode ON (value = 1) or OFF (value=0). If the coupling is off, the position will still be computed but the motor will not be updated by these new positions until coupling is turned ON again. Output : Returns nothing.","title":"set_status :"},{"location":"api/morj_api/morj_api.html#set_offset","text":"Input : { coupli n g :{ se t _o ffset : 35.78 }} type Argument value type : float Must be an angle value between -180 and +180 degrees Output : Returns nothing.","title":"set_offset :"},{"location":"api/morj_api/morj_api.html#get_offset","text":"Input : { coupli n g :{ ge t _o ffset : 1 }} type Argument value type : ignored Output : Returns the cur.","title":"get_offset :"},{"location":"api/morj_api/morj_api.html#set_zero","text":"Input : { coupli n g :{ se t _zero : 1 }} type Argument value type : ignored Sets the offset to correspond to the current instantaneous position, so that it's new value will be 0 after substraction. Output : Returns nothing.","title":"set_zero :"},{"location":"api/morj_api/morj_api.html#get_pos","text":"{coupling:{get_pos:1}} Returns the position of the coupling in degrees (between -180 and +180)","title":"get_pos :"},{"location":"api/morj_api/morj_api.html#get_summed_pos","text":"{coupling:{get_summed_pos:1}} Returns the position of the coupling in degrees (between max int32 and min int32). This position is the accumulated rotationnal position since the MORJ is turned on. (the position at turn on is 0) Negative direction is counterclockwise. Positive is clockwise.","title":"get_summed_pos :"},{"location":"api/morj_api/morj_api.html#add_turn","text":"{coupling:{add_turn:1}} Add turns (one per command max, whatever the value) if supplying +1 : adding a clockwise turn. If supplying -1 adding a counterclockwise turn.","title":"add_turn :"},{"location":"api/morj_api/morj_api.html#get_turns","text":"{coupling:{get_turns:1}} Get the number of current turns on the MORJ","title":"get_turns :"},{"location":"api/morj_api/morj_api.html#set_sensitivity","text":"{coupling:{set_sensitivity:600}} Set the number of steps that have to be overcomed before the MORJ can issue command to the motor. (in absolute steps) Default is 600 (as 1 turn is 9600, 600 = 1/16th of a turn)","title":"set_sensitivity :"},{"location":"api/morj_api/morj_api.html#get_last_cmd","text":"{coupling:{get_last_cmd:1}} Get the last_motor command send to the motor, in steps, relative to the last-last command.","title":"get_last_cmd :"},{"location":"api/morj_api/morj_api.html#get_last_scmd","text":"{coupling:{get_last_scmd:1}} Get the last_motor command send to the motor, in steps, accumulated from 0 (0 = position when the MORJ turned ON)","title":"get_last_scmd :"},{"location":"api/morj_api/morj_api.html#reset","text":"{coupling:{reset:1}} Set turns , summed_pos , offset , last_command , last_summed_command to 0","title":"reset :"},{"location":"api/morj_api/morj_api.html#motor","text":"All the commands motor accepts, directly forwarded :","title":"motor :"},{"location":"api/morj_api/morj_api.html#handshake_1","text":"{motor:{handshake:1}} Set turns , summed_pos , offset , last_command , last_summed_command to 0","title":"handshake:"},{"location":"api/morj_api/morj_api.html#go","text":"{motor:{go:50}} Go to a given position (relative to current position) in steps. can take positive or negative integers.","title":"go :"},{"location":"api/morj_api/morj_api.html#go_abs","text":"DEPRECATED : DO NOT USE. (Was used to send absolute command (from the 0 of the motor) but usually creates very dangerous situations as it is hard for user, as well as software, to keep track of a variable number with extreme certainty across two distributed devices, even more when asynchronously zeroing them or reboots / crashes / disconnections are possible \"features\")","title":"go_abs:"},{"location":"api/morj_api/morj_api.html#get_pos_1","text":"{motor:{get_pos:1}} DEPRECATED : DO NOT USE. (send absolute command (from the 0 of the motor) usually creates dangerous situations !!!!)","title":"get_pos:"},{"location":"api/morj_api/morj_api.html#stop","text":"{motor:{stop:50}} Stop the motor movement, while keeping track of the destination position.","title":"stop :"},{"location":"api/morj_api/morj_api.html#lock","text":"{motor:{lock:1}} NOT RECOMMANDED TO USE THIS COMMAND. Better use the MORJ specific lock manager by using the command {lock :{set_status:0}} to keep track of the lock status.","title":"lock :"},{"location":"api/morj_api/morj_api.html#zero","text":"{motor:{zero:1}} Set the OREF of the motor to the current position, at which the lock will come back. (by increments of one full turn)","title":"zero:"},{"location":"api/morj_api/morj_api.html#set_motor_accel","text":"{motor:{set_motor_accel:1}} Set the motor maximum speed in steps per second. By default, 10000","title":"set_motor_accel:"},{"location":"api/morj_api/morj_api.html#set_motor_max_speed","text":"{motor:{set_motor_max_speed:1}} Set the motor maximum acceleration in steps per second per second. By default, 20000 This is usually the variable that have the strongest effect on the ability of the motor to make fast movements. Use with care and try increasing values slowly. If you goo to high, the motor will stall and thus the controller will loose the zero position as there is no rotary encoder on the motor or MORJ shaft.","title":"set_motor_max_speed:"},{"location":"api/morj_api/morj_api.html#lock_1","text":"","title":"lock :"},{"location":"api/morj_api/morj_api.html#set_status_1","text":"{lock :{set_status:0}} Set the lock status of the motor. 0 is unlocked. 1 is locked. This takes priority over the BNC signal momentarily, but if the BNC status changes (Rise or Falls) after this command has been issued, the BNC status takes priority again.","title":"set_status :"},{"location":"api/morj_api/morj_api.html#shutter","text":"","title":"shutter :"},{"location":"api/morj_api/morj_api.html#set_status_2","text":"{shutter :{set_status:0}} Set the current shutter output BNC status. 0 is shutter deactivated (LOW). 1 is shutter activated. (HIGH). Remember that this MORJ output is set to INPUT_PULLUP, and so it can set a HIGH but not a LOW. To set a LOW, the other end of a BNC must be plugged into an input that can pull LOW. (all BNC compliant inputs usually can) This means that is the BNC is unplugged, there may be a RISING state detection at MORJ bootup on the shutter input line.","title":"set_status :"},{"location":"api/morj_api/morj_api.html#bnc_in_1","text":"This line is a RefractoryInterruptInput (subclass of InterruptInput) which gets activated by rising edges (trigger mode can be configured in the code, not in the API) When activated, it can't be again activated for the refractory period. For now the refractory period can't be set in API, but in the code (it's a fast thing to change it if necessary) The refractory period is by default 1300000 microseconds, so 1.3 seconds, a bit more than the duration of the 500 pulses sent to the camera for one trial. This allows this line to generate one single trigger at the very start of a 500 Hz pulse train. After 1.3 sec, it doesn't generate anything, but simply can be activated again. This class is used to set and count the status of a trial recordings, and help the PC to save and split recordings of 1.3 sec per trial.","title":"bnc_in_1 :"},{"location":"api/morj_api/morj_api.html#trigger","text":"{bnc_in_1 :{trigger:1}} Fakes a single trigger (here rising edge from code config) on the bnc_in_1input line. A trigger off will be happening 1.3 seconds after.","title":"trigger:"},{"location":"api/morj_api/morj_api.html#info","text":"{bnc_in_1 :{info:1}} Gets some info about the possible commands this class takes.","title":"info :"},{"location":"api/morj_api/morj_api.html#bnc_in_2","text":"This line is a PollingInput class, and thus checks regularly in the loop if it has been activated. This is a bit unprecise and can miss very short pulses, but bnc_in_2 is used to detect the start of the session, and the stop of the session, from the maze. It does so by detecting the rising edge (session start) of a very long pulse (a pulse the length of the session) and the falling edge (session_stop) of this pulse. Hence , precise timing is not an issue.","title":"bnc_in_2 :"},{"location":"api/morj_api/morj_api.html#info_1","text":"{bnc_in_2 :{info:1}} Gets some info about the possible commands this class takes.","title":"info :"},{"location":"api/morj_api/morj_api.html#trigger_rising","text":"{bnc_in_2 :{trigger_rising:1}} Fakes a single rising edge on the bnc_in_2 input line.","title":"trigger_rising"},{"location":"api/morj_api/morj_api.html#trigger_falling","text":"{bnc_in_2 :{trigger_falling:1}} Fakes a single falling edge on the bnc_in_2 input line.","title":"trigger_falling :"},{"location":"api/morj_api/morj_api.html#records","text":"","title":"records :"},{"location":"api/morj_api/morj_api.html#set_select","text":"{records:{set_select:{ \"quat\":1 , \"turns\" : 1 }}} sets the status of data sent into packets for the subset of data attributes you pass into the sub-json object. Possible keys are : \"quat\" \"accel\" \"gyro\" \"mag\" \"yaw_quat\" \"summed_yaw_coupling\" \"yaw_coupling\" \"command\" \"summed_command\" \"turns\" \"euler_quat\"","title":"set_select:"},{"location":"api/morj_api/morj_api.html#get_select","text":"{records :{get_select:1}} Gets the current selection of data into packets","title":"get_select:"},{"location":"api/morj_api/morj_api.html#start","text":"{records :{start:1}} Starts the sending of data packets at a regular interval.","title":"start:"},{"location":"api/morj_api/morj_api.html#stop_1","text":"{records:{stop:1}} Stops the sending of data packets at a regular interval.","title":"stop:"},{"location":"api/morj_api/morj_api.html#set_interval","text":"{records :{set_interval:50}} Set interval (in milliseconds) between to data packets. (default, 50 milliseconds)","title":"set_interval:"},{"location":"api/morj_api/morj_api.html#set_trial_duration","text":"{records :{set_trial_duration:1500}} The time interval (in milliseconds) after a bnc_in_1 trigger to declare the end of the trial (in recording) and increase the trial counter to 1. Set to 1500 milliseconds by default.","title":"set_trial_duration:"},{"location":"api/morj_api/morj_api.html#set_quat_ref","text":"{records :{set_quat_ref :1}} Saves a quaternion reference with the current position, to remember a \"zero\" 3D orientation position that can be substracted later in python to all the data of the session.","title":"set_quat_ref :"},{"location":"api/morj_api/morj_api.html#get_quat_ref","text":"{records :{get_quat_ref :1}} Gets the quaternion reference saved.","title":"get_quat_ref :"},{"location":"api/morj_api/morj_api.html#info_2","text":"{records :{info :1}} Gets some info about the possible commands this class takes.","title":"info :"},{"location":"code/maze_modules/modulex.html","text":"Purpose This class is the base class for any module. It principally comprises attributes and methods to access modules by name from json commands (see Maze API section of the documentation). It also allows basic function that can be usefull and common to any module, sensor or actuator alike, such as deactivation / reactivation of the module. Warning This class is not meant to be used alone, but to de derived to actually do something usefull. Example Usage : modulex module_object = modulex ( \"MyModuleName\" ) Constructor : modulex module_object ;","title":"Modulex"},{"location":"code/maze_modules/modulex.html#example-usage","text":"modulex module_object = modulex ( \"MyModuleName\" )","title":"Example Usage :"},{"location":"code/maze_modules/modulex.html#constructor","text":"modulex module_object ;","title":"Constructor :"},{"location":"code/maze_modules/servos.html","text":"Purpose This class is derived from the base modulex class. It is meant to store possible positions a servo can take, and make the process of switching between these positions as easy as possible Example Usage : servo servo_object = servo ( \"MyServoName\" ) Constructor : servo servo_object ;","title":"Servo"},{"location":"code/maze_modules/servos.html#example-usage","text":"servo servo_object = servo ( \"MyServoName\" )","title":"Example Usage :"},{"location":"code/maze_modules/servos.html#constructor","text":"servo servo_object ;","title":"Constructor :"},{"location":"code/maze_modules/waiters.html","text":"Purpose This class is meant to be used as a way to make easier the process of waiting for events in a non blocking way, when the necessity of instantaneous capture of transient events is not required (in which case, the use of hardware interrupts is preferable) Example Usage : Note : static Static is an argument to create a variable that will remain the same between function calls. Static var declaration is run only once so we don't mind putting it inside the \"root\" of the loop function. // loop run code repeatedly void loop () { static waiter waiter_object = waiter ( 1000 , waiter :: millisec , true ); if ( waiter_object ()){ // check if a memo is waiter_object . wait ( 1000 ); Serial . println ( \"DueTime\" ); } } Constructor : waiter waiter_object ; Called","title":"Waiter"},{"location":"code/maze_modules/waiters.html#example-usage","text":"Note : static Static is an argument to create a variable that will remain the same between function calls. Static var declaration is run only once so we don't mind putting it inside the \"root\" of the loop function. // loop run code repeatedly void loop () { static waiter waiter_object = waiter ( 1000 , waiter :: millisec , true ); if ( waiter_object ()){ // check if a memo is waiter_object . wait ( 1000 ); Serial . println ( \"DueTime\" ); } }","title":"Example Usage :"},{"location":"code/maze_modules/waiters.html#constructor","text":"waiter waiter_object ; Called","title":"Constructor :"}]}